# CH8_트랜잭션, 동시성 제어, 회복

# 01. 트랜잭션

### 1. 트랜잭션의 개념

- 트랜잭션
    - DBMS에서 데이터를 다루는 논리적인 작업의 단위이다.
    - 단일 SQL문을 사용하여 다루기도 하지만 여러 개의 SQL문을 다루기도 함.

- 트랜잭션을 정의하는 이유
    - 데이터베이스에서 데이터를 다룰 때 장애가 일어나는 경우가 있다. 트랜잭션은 장애 발생 시 데이터를 복구하는 작업의 단위가 된다.
    - 데이터베이스에서 여러 작업이 동시에 같은 데이터를 다룰 때가 있다. 트랜잭션은 이 작업을 서로 분리하는 단위가 된다.

```sql
START TRANSACTION
 1. A계좌에서 10000원 인출하는 SQL UPDATE문
 2. B계좌에서 10000원 입금하는 SQL UPDATE문
COMMIT
```

→ SQL문이 하나의 수행 단위라는 것을 알리기 위해 사용하는 문법은 START TRANSACTION문과 COMMIT문을 사용하여 트랜잭션의 시작과 끝을 표시한다.

- 예시

```sql
START TRANSACTION
1
2

3
UPDATE Customer
SET    balance=balance-10000
WHERE  name ='박지성';

4
UPDATE Customer
SET    balance=balance+10000
WHERE  name='김연아';
COMMIT
5
6
```

1. 박지성의 값을 하드디스크(데이터베이스)에서 주기억장치 버퍼로 읽어온다.
2. 김연아의 값을 하드디스크(데이터베이스)에서 주기억장치 버퍼로 읽어온다.
3. 박지성에서 10000원을 인출한 값을 저장한다.
4. 김연아에서 10000원을 입금한 값을 저장한다.
5. 박지성의 값을 주기억장치 버퍼에서 하드디스크(데이터베이스)에 기록한다.
6. 김연아의 값을 주기억장치 버퍼에서 하드디스크(데이터베이스)에 기록한다.

순서 : 1 - 2 - 3 - 4 - COMMIT - 5 - 6 - 완료

- 트랜잭션의 수행 과정

시작 → 수행(1,2,3,4) → 부분완료 → 버퍼내용 기록(5,6) → 완료

- 트랜잭션은 부분완료에서 종료되고, 사용자에게 알려진다.
- 완료가 되면, 다른 트랜잭션이 데이터를 자유롭게 사용할 수 있다.

### 2. 트랜잭션의 성질

- 트랜잭션
    - 다루는 데이터 : 데이터베이스에 저장된 데이터
    - 번역기 : DBMS
    - 성질 : 원자성, 일관성, 고립성, 지속성(ACID 성질)

- MySQL의 트랜잭션 제어 명령어(TCL)
    - SAVEPOINT(저장점) : 트랜잭션의 길이가 길면 트랜잭션의 중간 지점에 수정내용을 반영하는 포인트. ROLLBACK할 경우 처음부터 다시 실행하지 않고 SAVEPOINT로 되돌아간다.

| 표준 명령어 | 문법 | 설명 |
| --- | --- | --- |
| START TRANSACTION | SET TRANSACTION | 트랜잭션의 시작 |
| COMMIT | COMMIT | 트랜잭션의 종료 |
| ROLLBACK | ROLLBACK{TO <savepoint>} | 트랜잭션을 전체 혹은 <savepoint>까지 무효화시킴 |
| SAVE | SAVEPOINT <identifier> | <savepoint>를 만듦 |

- 원자성(Atomicity)
    - 트랜잭션에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 않아야 한다.

- 일관성(Consistency)
    - 트랜잭션을 수행하기 전이나 수행한 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.

- 고립성(Isolation)
    - 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야 한다.
    - 동시에 수행되는 트랜잭션이 같은 데이터를 가지고 충돌하지 않도록 제어하는 작업이 필요하다. 이 작업을 동시성 제어(concurrency control)라고 한다.

- 지속성(Durability)
    - 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.
    - 저장된 데이터베이스는 저장 직후 혹은 어느 때나 발생할 수 있는 정전, 장애, 오류에 영향을 받지 않아야 한다.

### 3. 트랜잭션과 DBMS

- DBMS는 트랜잭션이 원자성, 일관성, 고립성, 지속성을 유지할 수 있도록 지원한다.
    - 원자성 유지 : 회복(복구) 관리자 프로그램 작동
    - 일관성 유지: 무결성 제약조건 활용(한 개의 트랜잭션), 동시성 제어 알고리즘(두 개 이상 트랜잭션)
    - 고립성 유지 : 동시성 제어 알고리즘
    - 지속성 유지 : 회복 관리자 프로그램 이용

# 2. 동시성 제어

- 동시성 제어
    - 동시에 수행될 때, 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능을 동시성 제어라고한다.
- 상황 1
    - 트랜잭션 1(읽기)와 트랜잭션 2(읽기) - 동시 접근 허용
- 상황 2
    - 트랜잭션 1(읽기)와 트랜잭션 2(쓰기) - 허용 혹은 불가 선택
    - 오손 읽기, 반복불가능 읽기, 유령 데이터 읽기의 문제가 발생
- 상황 3
    - 트랜잭션 1(쓰기)와 트랜잭션 2(쓰기) - 허용 불가(LOCK을 이용)

### 1. 갱신손실 문제

- 갱신손실 문제
    - 두 개의 트랜잭션이 한 개의 데이터를 동신에 갱신할 때 발생하는 문제
    - 데이터베이스에서 절대 발생하면 안되는 현상

- 트랜잭션은 버퍼에 저장된 데이터로 작업을 수행한다.
- 데이터베이스(하드디스크)에 저장된 데이터 값은 주기억장치의 버퍼로 가져와야 읽을 수 있다.
- 버퍼의 내용을 데이터베이스에 기록하는 작업은 DBMS의 임무

### 2. 락

- 락의 개념
    - 트랜잭션이 데이터를 읽거나 수정할 때 데이터에 표시하는 잠금 장치이다.

- 락의 유형
    - 락은 트랜잭션이 다루는 데이터를 다른 트랜잭션이 접근하지 못하도록 막아 대기 상태로 만든다.
    - 공유락(LS, shared lock) : 트랜잭션이 읽기를 할 때 사용하는 락
    - 배태락(LX, exclusive lock) : 읽기/쓰기를 할 때 사용하는 락

- 락의 규칙
    - 데이터에 락이 걸려있지 않으면 트랜잭션은 데이터에 락을 걸 수 있다.
    - 트랜잭션이 데이터 X를 읽기만 할 경우 LS(X)를 요청하고, 읽거나 쓰기를 할 경우 LX(X)를 요청한다.
    - 다른 트랜잭션이 데이터에 LS(X)을 걸어두면, LS(X)의 요청은 허용하고 LX(X)는 허용하지 않는다.
    - 다른 트랜잭션이 데이터에 LX(X)을 걸어두면, LS(X)와 LX(X) 모두 허용하지 않는다.
    - 트랜잭션이 락을 허용받지 못하면 대기 상태가 된다.

- 2단계 락킹
    - 데이터에 락을 걸었다 풀고 다시 거는 중간 과정에 락의 해지 상태가 생기면서 다른 트랜잭션에게 중간 결과를 보일 수 있다는 것이다.
    - 2단계 락킹 기법
        - 확장단계 : 트랜잭션이 필요한 락을 흭득하는 단계로, 이 단계에서는 이미 흭득한 락을 해제하지 않는다.
        - 수축단계 : 트랜잭션이 락을 해제하는 단계로, 이 단계에서는 새로운 락을 흭득하지 않는다.

- 데드락
    - 두 개 이상의 트랜잭션이 각각 자신의 데이터에 대하여 락을 흭득하고 상대방 데이터에 대하여 락을 요청하면 무한 대기 상태에 빠질 수 있다.
    - 해결 방법
        - 두 개의 트랜잭션중 하나를 강제로 중지시킨다.

# 3. 트랜잭션 고립 수준

### 1. 트랜잭션 동시 실행 문제

- 오손 읽기 문제
    - 읽기 작업을 하는 트랜잭션1이 쓰기 작업을 하는 트랜잭션2가 작업한 중간 데이터를 읽기 때문에 생기는 문제

- 반복불가능 읽기
    - 트랜잭션1이 데이터를 읽고 트랜잭션2가 데이터를 쓰고(UPDATE), 트랜잭션1이 다시 한 번 데이터를 읽을 때 생기는 문제이다.
    - 트랜잭션1이 읽기 작업을 다시 한 번 반복할 경우 이전의 결과가 반복되지 않는 현상

- 유령데이터 읽기
    - 트랜잭션1이 데이터를 읽고 트랜잭션2가 데이터를 쓰고(INSERT), 트랜잭션 1이 다시 한 번 데이터를 읽을 때 생기는 문제이다.
    - 트랜잭션 1이 읽기 작업을 다시 한 번 반복할 경우 이전에 없던 데이터가 나타나는 현상을 유령 데이터 읽기라고 한다.
    - MySQL에서는 유령데이터 읽기가 발생하지 않는다. REPEATTABLE READ는 트랜잭션이 처음 데이터를 읽어올 때 SNAPSHOT을 구축하여 자료를 가져오며 그에 따라 다른 세션의 자료가 변경되더라도 동일한 결과를 보여주게 된다.

### 2. 트랜잭션 고립 수준 명령어

- 트랜잭션 고립 수준 표준 명령어와 발생 현상

| 발생가능한 문제 | 오손읽기 | 반복불가능 읽기 | 유령데이터 읽기 |
| --- | --- | --- | --- |
| READ UNCOMMITED | 가능 | 가능 | 가능 |
| READ COMMITTED | 불가능 | 가능 | 가능 |
| REPEATABLE READ | 불가능 | 불가능 | 가능 |
| SERIALZABLE | 불가능 | 불가능 | 불가능 |

# 4. 회복

- 회복 : 데이터베이스에 장애가 발생했을 때 데이터베이스를 일관성 있는 상태로 되돌리는 DBMS 기능

- 데이터베이스 시스템에서 발생할 수 있는 장애의 유형
    - 시스템 충돌
    - 미디어 장애
    - 응용 소프트웨어 오류
    - 자연재해
    - 부주의 혹은 태업

### 1. 트랜잭션의 회복

- 일단 변경한 내용(버퍼)를 로그(임시 디스크)에 기록한 후 데이터베이스에 반영한다.
- 장애가 발생하면 로그의 내용을 참조하여 트랜잭션의 변경 내용을 모두 반영하거나 아니면 반영하지 않는 방법으로 원자성, 지속성을 보장한다.
- 트랜잭션 수행 과정
    1. 트랜잭션이 시작하면 수행상태가 된다.
    2. 정상적으로 수행되면 COMMIT문을 만나 부분완료된다.
    3. 부분완료 후 버퍼의 내용을 데이터베이스에 기록하면 트랜잭션이 최종완료된다.
    4. 만약 수행 중에 문제가 생겨 완료 전에 실패하면 취소과정을 거쳐 이제까지 진행한 작업을 거꾸로 돌려놓는다. 변경된 데이터 중 혹시 데이터베이스에 이미 기록된 데이터가 있으면 로그를 이용하여 되돌린다.,
    5. 부분완료를 했으나 실패가 일어난 경우라면, 취소 과정을 거쳐 이제까지 진행한 작업을 거꾸로 돌려놓는다. 부분완료 후 실패하는 경우는 컴퓨터시스템 장애, 트랜잭션 오류, 데드락 등 여러 원인이 있다.

### 2. 로그 파일

- 로그 파일
    - 트랜잭션이 반영한 모든 데이터의 변경사항을 데이터베이스에 기록하기 전에 미리 기록해두는 별도의 데이터베이스
- 로그의 구조
    - <트랜잭션번호, 로그 타입, 데이터 항목 이름, 수정 전 값, 수정 후 값>
    - 로그 타입 : START, INSERT, UPDATE, DELETE, ABOR, COMMIT 등
- 데이터의 변경이 일어날 때마다 변경 내용은 로그 파일에 저장된다

### 3. 로그 파일을 이용한 회복

- 시스템 운영 중 장애가 발생하여 시스템이 다시 가동되었을 떄 DBMS는 로그 파일을 먼저 살펴본다.

- 트랜잭션의 재실행(REDO)
    - COMMIT연산이 로그에 있다는 것은 트랜잭션이 모두 완료되었다는 의미이다.
    - REDO: 로그를 보면서 트랜잭션이 변경한 내용을 데이터베이스에 다시 기록하는 과정

- 트랜잭션의 취소(UNDO)
    - UNDO: 버퍼의 변경 내용이 데이터베이스에 기록되어 있을 가능성이 있기 때문에 로그를 보면서 트랜잭션이 변경한 내용을 데이터베이스에서 원상복구시키는 과정

    - 즉시갱신
        - 부분완료 전에 버퍼의 갱신 데이터는 로그에 기록이 진행이 된 상태이며 부분완료 전에 버퍼의 일부 내용이 실제 데이터베이스에 반영이 될 수 있다.
    - 지연갱신
        - 부분완료 전에는 갱신 내용이 실제 데이터베이스에 반영이 되지 않은 상태

### 4. 체크포인트를 이용한 회복

- 체크포인트(검사점)
    - 몇 십 분 단위로 데이터베이스와 트랜잭션 로그 파일을 동기화한 후 동기화한 시점을 로그 파일에 기록해두는 방법

- 체크포인트 이전에 COMMIT기록이 있는 트랜잭션의 경우
    - 아무 작업 필요 없음.
- 체크포인트 이후에 COMMIT기록이 있는 트랜잭션의 경우
    - REDO(T) 진행
- 체크포인트 이후에 COMMIT기록이 없는 트랜잭션의 경우
    - UNDO(T)